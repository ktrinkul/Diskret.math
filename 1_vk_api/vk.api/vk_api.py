# -*- coding: utf-8 -*-
"""VK_API.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CBKgGcPE-hSSLwol79M_1rEP76gIYKau

##Задание 1
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install vk
# %pip install vk_api

import vk, vk_api

"""https://oauth.vk.com/authorize?client_id=51752593&display=page&redirect_uri=https://oauth.vk.com/blank.html&response_type=code&v=5.131

https://oauth.vk.com/access_token?client_id=51752593&client_secret=MIvWJSLJE5eXEvpSuMQU&redirect_uri=https://oauth.vk.com/blank.html&code=260b421801dc88dbeb
"""

access_token = 'vk1.a.dOzWj1DWJ9BAjg75Pu7MAYtuyOob5Rvs7Toh888Td1rX6Q76BTl2gtQcPcN1vE3SlZvF8u1AnOm9cmxKnq7cvVrp_L5t7_pKGujN-_6kxDAlZlfh-fEv2k05FEdU_tPb9ZBEokjLyWKigFtOqiN23xLrkEXyIsoogBcdQgptUSLXftvJOOKsu0hWW5tydSqS'

vk_session = vk_api.VkApi(token = access_token)
vk = vk_session.get_api()

my_id = 253450204

users = vk.users.get(user_id = my_id, fields = 'first_name, last_name, bdate, city, education')
users

import pandas as pd
dff = pd.DataFrame([users[0]])
dff

"""Задание 2"""

import requests
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

def get_friends(user_id):
  try:
    users = vk.friends.get(user_id = user_id, fields = 'first_name, last_name')
    return users["items"]
  except:
    return []

central_users = get_friends(my_id)
central_users = {user_dict['id']: user_dict.get('first_name')+ " " +user_dict.get('last_name')
                 for user_dict in central_users}
central_users[my_id] = 'Я'

central_users

#for friend_id in central_users.keys():
#  friends_users = get_friends(friend_id)
#  friends_users = {user_dict['id']: user_dict.get('first_name')+ " " +user_dict.get('last_name')
#                 for user_dict in friends_users}

#friends_users

import time
import random
graph = {}

for user_id in central_users.keys():
    friends_users = get_friends(user_id)
    friends_users = [user_dict['id']
                  for user_dict in friends_users]
    graph[user_id] = friends_users
    time.sleep(random.randint(1, 10) / 100)

graph

uniqie_users = set(graph.keys())

g = nx.Graph()
for user_id, user_friends in graph.items():
    g.add_node(central_users[user_id])
    for friends_id in user_friends:
        if friends_id in central_users:
            g.add_edge(central_users[user_id], central_users[friends_id])

def graph_plot():
    plt.figure(figsize=(12, 9))
    nx.draw_kamada_kawai(g, with_labels=False, node_size=50, width=0.5)
    plt.show()

graph_plot()

g.remove_node(central_users[my_id])

graph_plot()

def graph_plot2():
    plt.figure(figsize=(12, 9))
    nx.draw_kamada_kawai(g, with_labels=True, node_size=50, width=0.5)
    plt.show()

graph_plot2()

def graph_plot_save(name):
    plt.figure(figsize=(120, 90))
    nx.draw_kamada_kawai(g, with_labels=True, node_size=50, width=0.5)
    plt.savefig(name)

graph_plot_save('my_friends.png')

"""кластеры: верхний - школа, средний - вуз, нижний - оздоровительный санаторий, в сеередине справа - олимпиадный летний лагерь при мфти

часть с получением моих друзей на карте России
"""

import time
import random

def get_friends_country(user_id):
  try:
    users = vk.friends.get(user_id = user_id, fields = 'id, city,country')
    return users["items"]
  except:
    return []

city = get_friends_country(my_id)
friends_city = []

city

for friend in city:
  if 'city' in friend:
        friends_city.append({'id': friend['id'], 'city': friend.get('city')['title']})

#if 'city' in city[0]:
#friends_city.append({'id': friend['id'], 'city': friend.get('city')['title']})

friends_city_table = pd.DataFrame(data=friends_city)
friends_city_table.head()

friends_city_table['city'].value_counts()

friends_city_table['city'].value_counts().to_csv('friends_city.csv')

"""работа с геокодером"""

API_KEY = '1132f64f-65b9-4a4f-9330-208002aab3f1'

# Commented out IPython magic to ensure Python compatibility.
# %pip install requests
# %pip install clickhouse-driver

import requests
from dataclasses import dataclass

@dataclass
class YandexGeocoder:
    api_key: str
    geocoder_url: str = 'https://geocode-maps.yandex.ru/1.x'

    def adress_to_geopoint(self, address: str) -> str:
        response = requests.get(self.geocoder_url, params={
            'apikey': self.api_key,
            'geocode': address,
            'format': 'json',
        })
        response.raise_for_status()

        result = response.json()['response']['GeoObjectCollection']['featureMember']
        if not result:
            return None

        lat, lon = result[0]['GeoObject']['Point']['pos'].split(' ')
        return self._to_datalens_format(lon, lat)

    def _to_datalens_format(self, lon, lat):
        return f'[{lon},{lat}]'

geocoder = YandexGeocoder(api_key=API_KEY)

encoded_data = []
for friend in friends_city:
    address = friend['city']
    s = geocoder.adress_to_geopoint(address)
    encoded_data.append([s, friend['city']])
encoded_data[:10]

encoded_df = pd.DataFrame(data=encoded_data, columns=['coords', 'city'])
encoded_df

encoded_df.to_csv('coords.csv')

"""Задание 3 - Челябинск (158)"""

chek_users = []
popular_women = []
popular_men = []
count = 0

for i in range(1,29):
  chel_users_all_date = vk.users.search(fields = 'id, sex, bdate',
                                     city = 158, birth_day = i,
                                     count = 1000)
  chel_users_all = chel_users_all_date['items']

  for dict in chel_users_all:
    if 'bdate' in dict:
      if len(dict['bdate']) > 7:
        if dict['sex']==1 or dict['sex']==2:
          if count < 10000:
            count+=1
            chek_users.append(dict)

women = []
men = []
years = []

for dict in chek_users:
  day, month, year = dict['bdate'].split('.')
  years.append(year)
  if dict['sex']==1:
    women.append({'years': year})
  else:
    men.append({'years': year})

chel_years = set(years)
chel_years

dfwomen = pd.DataFrame(women)
dfwomen.describe(include = 'all')
dfwomen['years'].value_counts()

dfmen = pd.DataFrame(men)
dfmen.describe(include = 'all')
dfmen['years'].value_counts()

dfwomen['years'].value_counts().to_csv('dfwomen.csv')
dfmen['years'].value_counts().to_csv('dfmen.csv')

"""Ссылка на дашборд"""

https://datalens.yandex.ru/2a00o5limoyqr-hw-1-2

"""задание на имена"""

cnt1 = 0
random_users_name = []
women_name = []
men_name = []

for i in range(1, 29):
    users1 = vk.users.search(fields = 'id, sex, first_name', city = 158, birth_day = i, count = 1000)
    new_massiv1 = users1['items']
    for dict in new_massiv1:
        if 'sex' in dict:
            if ((dict['sex'] == 1) or (dict['sex'] == 2)):
                    if (cnt1 < 10000):
                        cnt1+=1
                        random_users_name.append(dict)

#len(random_users_name)

for dict in random_users_name:
  if dict['sex']==1:
    women_name.append({'name_w': dict['first_name']})
  if dict['sex']==2:
    men_name.append({'name_m': dict['first_name']})

#len(men)

dfwomen_name = pd.DataFrame(women_name)
dfwomen_name.describe(include = 'all')
dfwomen_name['name_w'].value_counts()

"""самое популряное женское имя в городе Челябинск - Анастасия (554)"""

dfmen_name = pd.DataFrame(men_name)
dfmen_name.describe(include = 'all')
dfmen_name['name_m'].value_counts()

"""самое популярное мужское имя - Александр (532)"""

dfwomen_name['name_w'].value_counts().to_csv('dfwomen_name.csv')
dfmen_name['name_m'].value_counts().to_csv('dfmen_name.csv')